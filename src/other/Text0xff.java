package other;

/**
 * Created by xuye on 2017年9月21日
 * <p>
 * 1、为什么java里byte的类型是-128~127而不是-127~127？因为有+-0，-0变为了-128
 * 
 * 2、为什么byte值要&0xff？编解码时，保持二进制数据的一致性。因为一些转换方法是将byte转成int会改变实际的数值，为了保持低位的数值真实
 * 
 * 3、为什么byte值&0xff后，输出时值变了？因为按位与时强制byte转成int，自动补高位，使补码变了，对应的原码也变了
 */
public class Text0xff {
	public static void main(String[] args) {
		byte[] a = new byte[10];
		a[0] = -127;
		System.out.println(a[0]);

		/**
		 * 按理来说，a[0]&0xff就是自己才对，但是结果却不再是-127了，why?
		 * 
		 * -127 = 11111111 &0xff 应该还是11111111的
		 * 
		 * 原因是-127 = 11111111是原码的换算方式，实际上在机器上使用的是其补码10000001。然后向控制台输出时，
		 * 自动从byte转成了int类型，即从10000001变成了11111111 11111111 11111111
		 * 10000001，这个补码换成原码(-1再对最高的符号位外的所有位取反)就是10000000 00000000 00000000
		 * 01111111还是-127
		 * 
		 * 但是现在为了保持二进制数据的一致性，&0xff后，保留了低8位的值，高24位全变成了0，即现在补码是00000000 00000000
		 * 00000000 10000001，由于这个补码现在最高位是0是个正数，所以其原码也是这个值10000001，换算成10进制就变成了129
		 * 
		 * 
		 * 【反码】正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
		 * 
		 * [+1] = [00000001]原 =[00000001]反
		 * 
		 * [-1] = [10000001]原 = [11111110]反
		 * 
		 * 【补码】正数的原码是其本身，负数是其反码+1
		 * 
		 * 人可以识别原码的符号再计算真值，但是计算机日常操作不好再对符号做区分，会增加复杂度，所以让符号位也参与计算。
		 * 
		 * 但是用原码计算负数时，会出错，因为符号位加进来了，比如1-1=0，原码是00000001+10000001 = 10000010
		 * 就变成-2了,所以用反码解决负数的问题。但是0可以有+0和-0，又有问题了。所以有了补码。
		 * 
		 * 所以现在计算机都使用补码来计算了。
		 */

		int c = a[0] & 0xff;
		// byte c = a[0] & 0xff;这样写会报错，因为&这个操作强制使用32位数，会提示你使用int c
		System.out.println(c);
	}
}
